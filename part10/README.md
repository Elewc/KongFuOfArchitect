## 第十部分  编译原理


## 前言

如何理解编译器？

编译器能帮助我们做哪些事情？


## 注意事项

请基于macos或者linux发行版构架学习环境

## 自己折腾

为什么自己新建一个项目？

答案是，不亲自动手不清楚会遇到那些坑，宫学文老师的项目现在更新比较慢，建议阁下自己下载下来自己折腾，或者使用我重新构建和优化的版本

我自己构建的版本 README 增加了编译前 编译后 一些配置，为了提高阁下的开发体验，我之前也发布了两篇浅述，请阁下移步

- 源码地址：[xiaomiwujiecao/playscript-java: 极客时间-《编译原理之美》playScript 脚本语言相关代码，其已包含编译后的源码，可自行测试，同时也包含了 Idea 相关的配置，可自行修改并重新编译](https://github.com/xiaomiwujiecao/playscript-java)
- [windows 流畅开发准备工作 - 疯狂的AI](https://ai.nodejs7.com/2020/01/14/118.html)
- [windows cmder 仿 mac 操作习惯配置 命令行 - 疯狂的AI](https://ai.nodejs7.com/2020/01/16/121.html)


## 笔记【更新中】

- [06 | 编译器前端工具（一）：用Antlr生成词法、语法分析器 ](https://ai.nodejs7.com/2020/01/02/70.html)
- [07 | 编译器前端工具（二）：用Antlr重构脚本语言 - 疯狂的AI](https://ai.nodejs7.com/2020/01/03/72.html)
- [08 | 作用域和生存期：实现块作用域和函数 - 疯狂的AI](https://ai.nodejs7.com/2020/01/03/75.html)
- [09 | 面向对象：实现数据和方法的封装 - 疯狂的AI](https://ai.nodejs7.com/2020/01/13/111.html)
- [10 理解闭包原理 - 疯狂的AI](https://ai.nodejs7.com/2020/01/20/129.html)
- [14 | 前端技术应用（一）：如何透明地支持数据库分库分表？ 点击进入详情](14/README.md)
    - [SQLite 语法文件](./14/SQLite.g4)

## 现代语言设计
    
    
- 功能完备的语言包含了
  - 编译器
  - 运行时
    - 内存管理
    - 并发机制
    - 解释器
    - ...
  - 标准库   
    - 算术计算
    - 字符串处理
    - 文件读写
    - ...
- 如何设计一门计算机语言
  - 清晰的需求
  - 良好的设计
  - 历史中的语言往往都是一个流行的系统的脚本
   - 设计问题
    - 案例
      - js
        - 解释执行的语言
        - 嵌入到 HTML 中 ，方便下载和执行
        - 跨平台
        - 对编译速度有要求
          - 词法分析
          - 懒解析 
          
- 现代语言篇
   - 各门语言的编译器的前端、中端和后端技术做对比和总结          
   - 对语言的运行时和标准库的实现技术做解析  
     - 对语言的运行时和标准库的宏观探讨
     - 是垃圾收集机制
     - 是并发模型
   - 计算机语言设计上的 4 个高级话题
     - 元编程技术
     - 泛型编程技术     
     - 面向对象语言的实现机制
     - 函数式编程语言的实现机制
     
- 前端编译技术
  - 手写词法编译器
    - 特点
      - 实现较简单
      - 便于做优化
      - 便于处理特殊情况
        - 例如 `mysql` 词法分析器处理字符集下某个字符串是否是合法的token
  - 自顶向下分析为主的语法分析器
    - 手写 vs 工具生成
    - 差异化的语义分析功能
    - 友好的语言特性
      - 自动类型推导
        - 自动类型推导可以减少编程时与类型声明有关的工作量
        -  C++ 11 中，采用了 auto 关键字做类型推导。
        - Kotlin 中用 var 声明变量，也支持显式类型声明和类型推导两种方式
        - Go 语言，会用“:=” 让编译器去做类型推导
        - Java 语言也在 Java  10 版本加上了类型推导功能
      - Null 安全性
       - Null 引用其实是托尼·霍尔（Tony Hoare）在 1960 年代在设计某一门语言（ALGOL W）时引入的，后来也纷纷被其他语言所借鉴。
       - 以 Kotlin 为例，在缺省情况下，它不允许你把 Null 赋给变量，因此这些变量就不需要检查是否为 Null。  
       - 安全调用（Safe Call）
         - 采用“?.”操作符来访问
       - Null 安全性在编译器里应该怎样实现呢  
         - 友好的语法糖
           - 分号推断
           - 单例对象
           - 纯数据的类
             - jdk14 支持 Record 类
           - 没有原始类型，一切都是对象  
         - 一些友好的词法规则
           - 嵌套的多行注释
           - 标识符支持 Unicode
             - 你可以用中文来声明变量和函数名称  
           - 多行字符串字面量  
           
- 中端编译技术 IR 与 SSA 

  - SSA
    - 源代码中的一个变量，会变成多个版本，每次赋值都形成一个新版本
    - 在 SSA 中，它们都叫做一个值（Value）
    - 对变量的赋值就是对值的定义（def）
    - 定义出来之后 可以在定义其他值的时候被使用(use)    
    - 形成 use-def 链
    - 特点
      - 定义未被使用--死代码删除
      - 常数折叠，顺着链，替换值，形成常数传播
      - 定义相同，值相同，可使用公共子表达式消除
  - Sea of Nodes 的特点总结
    - 特点
      - 是把数据流图和控制流图合二为一，从而更容易实现全局优化  
      - 在生成图的过程中，顺带就可以完成很多优化了  
      - 从高到低的多层次 IR
        - 对一个数组元素的访问
        - 访问一个对象的成员变量
        - 本地变量的访问   
        
 - 优化算法的总结
   - 编译器基于IR的处理
     - 层层地做 Lower
     - 对 IR 做分析
     - 实现各种优化算法       
   - 特点
     - 有些基本的优化，是每个编译器都会去实现的
     - 对于解释执行的语言，其编译器能做的优化是有限的
       - Python 类型检查都是在运行期进行
         - 根据不同的类型执行不同的功能
         - 所有对象都是在堆中申请的
       - JVM
         - 编译器已做类型检查
         - 简单优化 没消除无用代码
         - 内联优化和逃逸分析没有做
       - V8 的 Ignition 解释器
         - 在寄存器利用方面比JAVA更有优势
         - 但是动态类型拖了后腿  
   - 动态类型语言 
     - 优化编译首要任务是类型推断      
     - 要为自己可能产生的推理错误做好准备，在必要的时候执行逆优化功能。
     - Julia 也是动态类型的语言，但它采取了另一个编译策略。它会为一个函数不同的参数类型组合，编译生成对应的机器码。
   - JIT 编译器可以充分利用推理性的优化机制  
   - 对于静态类型的语言，不同的编译器的优化程度也是不同的
   
- 后端编译总结
  - 关键算法
    - 指令选择
      - 模式树（Pattern Tree）
      - 对一个 AST 生成指令，就是用这样的模式树或瓦片来覆盖整个 AST 的过程。所以，这样的算法也叫做基于模式匹配的指令生成算法。
      - `#4`（Store_Offset）
        - 比如你在对象地址上加一个偏移量，就能获得成员变量的地址，并把数值保存到这个地址上
      - `#9`（Lea）  相当于 x86 指令集中的 Lea 指令
      - 实现的算法
        - 第一种
          - 我们采取深度优先的后序遍历，也就是按照“左子节点 -> 右子节点 -> 父节点”的顺序遍历，针对每个节点去匹配上面的模式。
          - 这种方法，是自底向上的做树的重写。
        - 第二种
          - 类似 `Graal` 编译器所采用的方法，自顶向下的做模式匹配  
          - 是找出用模式匹配来覆盖 AST 的所有可能的模式，并找出其中 Cost 最低的
        - 第三种
          - BURS 算法  
    - 寄存器分配
      - 线性扫描算法并不能获得寄存器分配的最优解
      - 线性扫描算法可以采用一些策略，让一些使用频率低的变量被溢出，而像高频使用的循环中的变量，就保留在寄存器里    
      - 还有一些其他提升策略。比如，当存在多余的物理寄存器以后，还可以把之前已经溢出的变量重新复活到寄存器里。
      - 思路
        - 线性扫描整个代码，并给活跃变量分配寄存器。如果物理寄存器不足，那么就选择一个变量，溢出到内存中
    - 指令排序


- 编译器后端与语言的设计
  -因素
    - 平衡编译速度和优化效果
    - 确定所支持的硬件平台       
    - 设计后端 DSL
    
 - 运行时
   -  一门语言的构成
     -  编译器
     - 运行时
       - 每种语言都有特定的执行模型
         - 执行模型需要运行时系统(Runtime System)的支持
           - 简称为 “运行时”
       - 包含的主要功能
         - 程序运行机制
         - 内存管理机制
         - 并发机制   
       - java 运行时
         - JVM 规定了一套程序的运行机制
           - 定义了一套字节码来运行程序  
           - 规定了一套类型系统，包括基础数据类型、数组、引用类型等  
           - 定义了 class 文件的结构  
           - 提供了一个基于栈的解释器，来解释执行字节码
           - JVM 还支持即时编译成机器码并执行的机制
           - Java 程序之间的互相调用，需要遵循一定的调用约定或二进制标准，包括如何传参数等等
         - JVM 对内存做了统一的管理
           - 把内存划分为程序计数器、虚拟机栈、堆、方法区、运行时常量池和本地方法栈等不同的区域  
         - JVM 封装了操作系统的线程模型，为应用程序提供了并发处理的机制
           - JVM 实际上提供了一个基础的对象模型，JVM 上的各种语言必须遵守
           - 基于 JVM 的语言程序要去调用 C 语言等生成的机器码的库，会比较难。  
           - 在内存管理上，程序不能直接访问内存地址，也不能手动释放内存
           - 在并发方面，JVM 只提供了线程机制。
       - python 运行时
         - Python 也提供了一套字节码，以及运行该字节码的解释器
         - 字节码中操作的那些标识符，都是 Python 的对象引用。
         - 在内存管理方面，Python 也提供了自己的机制，包括对栈和堆的管理
         - Python 运行程序的时候，有些时候是运行机器码，比如内置函数，而有些时候是解释执行字节码。    
         - 栈帧跟 C 语言程序的栈帧是没啥区别的
         - 解释器本身主要就是一个 C 语言实现的函数，而操作数栈就是这个函数里用到的本地变量。
         因此操作数栈也会像其他本地变量一样，被优化成尽量使用物理寄存器，从而提高运行效率。
         - 栈桢中的操作数栈，其实是有可能基于物理寄存器的。
         - Python 还提供了对堆的管理机制。
         - 通过 Python 提供的一个 Arena 机制，使得内存的申请和释放更加高效、灵活
         - Python 还提供了基于引用的垃圾收集机制
         - `Python` 把操作系统的线程进行了封装. 让 `Python` 程序能支持基于线程的并发。同时，它也实现了协程机制
       - C、C++、Go 的运行时
         - C 语言最主要的运行时，实际上就是操作系统  
           - 深入使用 C 语言，某种意义上就是要深入了解操作系统的运行机制。
         - C 没有自动内存管理机制
         - C 可以直接使用线程机制 但是操作系统没有提供协程和Actor机制，C 没有这个机制
         - 不过有一个程序 crt0.o，有时被称作是 C 语言的运行时
         - Go 语言虽然也是编译成二进制的可执行文件，但它的运行时要复杂得多
         - Go 语言最显著的特点是提供了自己的并发机制，也就是 goroutine。
         - 在 Android 平台上，你可以把 Java 程序以 AOT 的方式编译成可执行文件  
     - 标准库 
       - 库和标准库
         - 根据库的使用场景和与编译器的关系
         - 标准库
           - 标准库，供用户的程序调用。
         - 运行时库
           - 运行时库，它们不是由用户直接调用的，而是运行时的组成部分。
         - 内置函数
           -  Built-in 或者 Intrincics 的内置函数，它们是用来辅助生成机器码的。
     - 标准库的特殊性
       - 有的库可以用本语言来实现，而有的库必须要用其他语言来实现
       - 第二，标准库的接口不可以经常变化，甚至是要保持一直不变
       - ，标准库往往集中体现了一门语言的核心特点。
     - 标准库需要包含什么功能？
       - 包含 IO 功能，包括文件 IO、网络 IO
         - 终端本身就相当于一个文件，这实际上是用了文件 IO 功能。
       - 支持内置的数据类型。
       - 支持各种容器型的数据结构。
       - 对日期、图形界面等各种不同的功能支持    
## 版权声明

引用内容版权归 【极客时间】 所有
